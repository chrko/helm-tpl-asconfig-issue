# Combination of tpl and .Files.Glob.AsConfig leads to blank issues

<!-- TOC -->
* [Combination of tpl and .Files.Glob.AsConfig leads to blank issues](#combination-of-tpl-and-filesglobasconfig-leads-to-blank-issues)
  * [Examples](#examples)
    * [Example 1: fluent-bit classic configuration style](#example-1-fluent-bit-classic-configuration-style)
      * [Inputs](#inputs)
      * [Output of helm template](#output-of-helm-template)
        * [Actual](#actual)
        * [Expected](#expected)
    * [Example 2: fluent-bit YAML configuration style](#example-2-fluent-bit-yaml-configuration-style)
      * [Inputs](#inputs-1)
      * [Output of helm template](#output-of-helm-template-1)
        * [Actual](#actual-1)
        * [Expected](#expected-1)
  * [Issue description and workarounds](#issue-description-and-workarounds)
    * [Workaround 1 - Changing the config files](#workaround-1---changing-the-config-files)
    * [Workaround 2 - Change order of tpl and "AsConfig" #1](#workaround-2---change-order-of-tpl-and-asconfig-1)
    * [Workaround 3 - Change order of tpl and "AsConfig" #2](#workaround-3---change-order-of-tpl-and-asconfig-2)
      * [Reusable helper template](#reusable-helper-template)
  * [Proposals for remediation](#proposals-for-remediation)
<!-- TOC -->

I currently have the use case to template config files for fluent-bit.
Instead of having inline configuration within a ConfigMap definition,
I decided to extract these files in a parallel structure to `templates/`
and dynamically include in a ConfigMap using the following snippet:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fb-config
data: {{- tpl (.Files.Glob "fluent-bit/conf/*").AsConfig . | nindent 2 }}
```

Depending on the template contents of a file grabbed by the glob,
this leads to - on first look - unexpected results.

In the following examples I'll take the actual fluent-bit configuration use case,
but this is a general problem of this ("naive") templating approach.
In certain important cases instead of spaces I use `·`.

## Examples

### Example 1: fluent-bit classic configuration style

#### Inputs

```
# fluent-bit/conf/fluent-bit.conf
# Service conf, inputs, etc.

[FILTER]
    Name kubernetes
    # […]

{{- if .Values.filters.extraEntries }}
{{ .Values.filters.extraEntries }}
{{- end }}

# outputs etc.
```

```yaml
# values.yaml
filters:
  extraEntries: |
    [FILTER]
        Name record_modifier
        Match splunk
        Remove_key kubernetes
```

#### Output of helm template

Note that for the inserted filter definition it's only intended 6 spaces in the actual result generated by Helm.
The expected one should contain 8 spaces - 4 from the `extraEntries` string + 4 from the YAML indentation within the ConfigMap definition.

##### Actual
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
data:
  fluent-bit.conf: |
    # fluent-bit/conf/fluent-bit.conf
    # Service conf, inputs, etc.
  
    [FILTER]
        Name kubernetes
        # […]
    [FILTER]
      Name record_modifier
      Match splunk
      Remove_key kubernetes
  
  
    # outputs etc.
```

##### Expected
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
data:
  fluent-bit.conf: |
    # fluent-bit/conf/fluent-bit.conf
    # Service conf, inputs, etc.
  
    [FILTER]
        Name kubernetes
        # […]
    [FILTER]
        Name record_modifier
        Match splunk
        Remove_key kubernetes
  
  
    # outputs etc.
```


### Example 2: fluent-bit YAML configuration style

This is example is converted to the new fluent-bit YAML configuration style.

#### Inputs

```yaml
# fluent-bit/conf/fluent-bit.yaml
# […]
pipeline:
  filters:
    - name: kubernetes
      # […]
{{- toYaml .Values.filters.extraYamlEntries | nindent 4 }}
# […]
```

```yaml
# values.yaml
filters:
  extraYamlEntries:
    - name: record_modifier
      match: splunk
      removeKey: kubernetes
```

#### Output of helm template

Note that the indentation of the inserted array element is 2 spaces short.

##### Actual
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
data:
  fluent-bit.yaml: |
    # fluent-bit/conf/fluent-bit.yaml
    # […]
    pipeline:
      filters:
        - name: kubernetes
          # […]
      - match: splunk
        name: record_modifier
        removeKey: kubernetes
    # […]
```

##### Expected
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
data:
  fluent-bit.yaml: |
    # fluent-bit/conf/fluent-bit.yaml
    # […]
    pipeline:
      filters:
        - name: kubernetes
          # […]
        - match: splunk
          name: record_modifier
          removeKey: kubernetes
    # […]
```

## Issue description and workarounds

The missing spaces are caused by the order of invocation of `tpl` and `AsConfig` and the resulting blank manipulations.
The `.AsConfig` already introduces 2 spaces and after this operation the templating is going to happen.
So `tpl` is actually processing the following content:

```yaml
fluent-bit.conf: |
  # fluent-bit/conf/fluent-bit.conf
  # Service conf, inputs, etc.

  [FILTER]
      Name kubernetes
      # […]

  {{- if .Values.filters.extraEntries }}
  {{ .Values.filters.extraEntries }}
  {{- end }}

  # outputs etc.
fluent-bit.yaml: |
  # fluent-bit/conf/fluent-bit.yaml
  # […]
  pipeline:
    filters:
      - name: kubernetes
        # […]
  {{- toYaml .Values.filters.extraYamlEntries | nindent 4 }}
  # […]
```

This is being templated and afterward again indented by spaces for the surrounding ConfigMap.

### Workaround 1 - Changing the config files

So in case staying with `tpl (.Files.Glob "").AsConfig .` approach, the source files need to be modified to get the following data before invocation of `tpl`:

```yaml
fluent-bit.conf: |
  # fluent-bit/conf/fluent-bit.conf
  # Service conf, inputs, etc.

  [FILTER]
      Name kubernetes
      # […]

  {{- if .Values.filters.extraEntries }}
  {{ .Values.filters.extraEntries | indent 2 }}
  {{- end }}

  # outputs etc.
fluent-bit.yaml: |
  # fluent-bit/conf/fluent-bit.yaml
  # […]
  pipeline:
    filters:
      - name: kubernetes
        # […]
  {{- toYaml .Values.filters.extraYamlEntries | nindent 6 }}
  # […]
```

->

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
data:
  fluent-bit.conf: |
    # fluent-bit/conf/fluent-bit.conf
    # Service conf, inputs, etc.
  
    [FILTER]
        Name kubernetes
        # […]
      [FILTER]
        Name record_modifier
        Match splunk
        Remove_key kubernetes
    
  
    # outputs etc.
  fluent-bit.yaml: |
    # fluent-bit/conf/fluent-bit.yaml
    # […]
    pipeline:
      filters:
        - name: kubernetes
          # […]
        - match: splunk
          name: record_modifier
          removeKey: kubernetes
    # […]
```

### Workaround 2 - Change order of tpl and "AsConfig" #1

Instead of modifying the source config files,
you can manually do things in the correct order.
This variant is not *exactly* the same as the input files (the extra line break at the end of `fluent-bit.conf`).

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
data:
  {{- $currentContext := . }}
  {{- range $path, $_ := $currentContext.Files.Glob "fluent-bit/conf/*" }}
  {{ base $path }}: |-
    {{- tpl ($currentContext.Files.Get $path) $currentContext | nindent 4 }}
  {{- end }}
```

->

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
data:
  fluent-bit.conf: |-
    # fluent-bit/conf/fluent-bit.conf
    # Service conf, inputs, etc.
    
    [FILTER]
        Name kubernetes
        # […]
    [FILTER]
        Name record_modifier
        Match splunk
        Remove_key kubernetes
    
    
    # outputs etc.
    
  fluent-bit.yaml: |-
    # fluent-bit/conf/fluent-bit.yaml
    # […]
    pipeline:
      filters:
        - name: kubernetes
          # […]
        - match: splunk
          name: record_modifier
          removeKey: kubernetes
    # […]
```

### Workaround 3 - Change order of tpl and "AsConfig" #2

Instead of trying to get things right on our own,
build up a dict  and let `toYaml` to the conversion.
This exactly reproduces the (templated) input files.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
data:
  {{- $currentContext := . }}
  {{- $fileDict := dict }}
  {{- range $path, $_ := $currentContext.Files.Glob "fluent-bit/conf/*" }}
    {{- $_ := set $fileDict (base $path) (tpl ($currentContext.Files.Get $path) $currentContext) }}
  {{- end }}
  {{- toYaml $fileDict | nindent 2 }}
```

->

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
data:
  fluent-bit.conf: |
    # fluent-bit/conf/fluent-bit.conf
    # Service conf, inputs, etc.
  
    [FILTER]
        Name kubernetes
        # […]
    [FILTER]
        Name record_modifier
        Match splunk
        Remove_key kubernetes
  
  
    # outputs etc.
  fluent-bit.yaml: |
    # fluent-bit/conf/fluent-bit.yaml
    # […]
    pipeline:
      filters:
        - name: kubernetes
          # […]
        - match: splunk
          name: record_modifier
          removeKey: kubernetes
    # […]
```

#### Reusable helper template

Defining this as a reusable helper template could look like this:

```yaml
{{- define "tpl.files.glob.asConfig" -}}
  {{- $context := required "Current chart context (including .Files)" .context -}}
  {{- $glob := required "Glob pattern `.glob` must be set" .glob -}}

  {{- $fileDict := dict -}}

  {{- range $path, $_ := $context.Files.Glob $glob -}}
    {{- $_ := set $fileDict (base $path) (tpl ($context.Files.Get $path) $context) -}}
  {{- end -}}

  {{- toYaml $fileDict -}}
{{- end -}}

apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
data: {{- include "tpl.files.glob.asConfig" (dict "context" . "glob" "fluent-bit/conf/*") | nindent 2 }}
```

## Proposals for remediation

In my mind I have the following proposals:

- Extend documentation to include a warning about the combination of `tpl` and `.AsConfig`
  (so that people do not question themselves regarding counting the spaces required for `nindent`, see workaround 1, and assuming that their mind or `indent`/`nindent` is broken ¯\_(ツ)_/¯).

- Add a new function doing more or less the same as the showed reusable helper template definition,
  so that calling this is less verbose and a central implementation is provided and tested.

- Mark this as a non-issue/out of scope for Helm. I'm actually not sure that this is a valid approach and should be a supported use case.
